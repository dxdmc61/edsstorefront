/*!
 * Link Click tracking for Snowplow v3.24.6 (http://bit.ly/sp-js)
 * Copyright 2022 Snowplow Analytics Ltd, 2010 Anthon Pang
 * Licensed under BSD-3-Clause
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.snowplowLinkClickTracking = {}));
})(this, (function (exports) { 'use strict';

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }

  typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
  };

  /*!
   * Core functionality for Snowplow JavaScript trackers v3.24.6 (http://bit.ly/sp-js)
   * Copyright 2022 Snowplow Analytics Ltd, 2010 Anthon Pang
   * Licensed under BSD-3-Clause
   */

  /*
   * Copyright (c) 2022 Snowplow Analytics Ltd, 2010 Anthon Pang
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the documentation
   *    and/or other materials provided with the distribution.
   *
   * 3. Neither the name of the copyright holder nor the names of its
   *    contributors may be used to endorse or promote products derived from
   *    this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  function payloadBuilder() {
      var dict = {}, allJson = [], jsonForProcessing = [], contextEntitiesForProcessing = [];
      var processor;
      var add = function (key, value) {
          if (value != null && value !== '') {
              // null also checks undefined
              dict[key] = value;
          }
      };
      var addDict = function (dict) {
          for (var key in dict) {
              if (Object.prototype.hasOwnProperty.call(dict, key)) {
                  add(key, dict[key]);
              }
          }
      };
      var addJson = function (keyIfEncoded, keyIfNotEncoded, json) {
          if (json && isNonEmptyJson(json)) {
              var jsonWithKeys = { keyIfEncoded: keyIfEncoded, keyIfNotEncoded: keyIfNotEncoded, json: json };
              jsonForProcessing.push(jsonWithKeys);
              allJson.push(jsonWithKeys);
          }
      };
      var addContextEntity = function (entity) {
          contextEntitiesForProcessing.push(entity);
      };
      return {
          add: add,
          addDict: addDict,
          addJson: addJson,
          addContextEntity: addContextEntity,
          getPayload: function () { return dict; },
          getJson: function () { return allJson; },
          withJsonProcessor: function (jsonProcessor) {
              processor = jsonProcessor;
          },
          build: function () {
              processor === null || processor === void 0 ? void 0 : processor(this, jsonForProcessing, contextEntitiesForProcessing);
              return dict;
          }
      };
  }
  /**
   * Is property a non-empty JSON?
   * @param property - Checks if object is non-empty json
   */
  function isNonEmptyJson(property) {
      if (!isJson(property)) {
          return false;
      }
      for (var key in property) {
          if (Object.prototype.hasOwnProperty.call(property, key)) {
              return true;
          }
      }
      return false;
  }
  /**
   * Is property a JSON?
   * @param property - Checks if object is json
   */
  function isJson(property) {
      return (typeof property !== 'undefined' &&
          property !== null &&
          (property.constructor === {}.constructor || property.constructor === [].constructor));
  }

  /*
   * Copyright (c) 2022 Snowplow Analytics Ltd, 2010 Anthon Pang
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the documentation
   *    and/or other materials provided with the distribution.
   *
   * 3. Neither the name of the copyright holder nor the names of its
   *    contributors may be used to endorse or promote products derived from
   *    this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  var label = 'Snowplow: ';
  var LOG_LEVEL;
  (function (LOG_LEVEL) {
      LOG_LEVEL[LOG_LEVEL["none"] = 0] = "none";
      LOG_LEVEL[LOG_LEVEL["error"] = 1] = "error";
      LOG_LEVEL[LOG_LEVEL["warn"] = 2] = "warn";
      LOG_LEVEL[LOG_LEVEL["debug"] = 3] = "debug";
      LOG_LEVEL[LOG_LEVEL["info"] = 4] = "info";
  })(LOG_LEVEL || (LOG_LEVEL = {}));
  var LOG = logger();
  function logger(logLevel) {
      if (logLevel === void 0) { logLevel = LOG_LEVEL.warn; }
      function setLogLevel(level) {
          if (LOG_LEVEL[level]) {
              logLevel = level;
          }
          else {
              logLevel = LOG_LEVEL.warn;
          }
      }
      /**
       * Log errors, with or without error object
       */
      function error(message, error) {
          var extraParams = [];
          for (var _i = 2; _i < arguments.length; _i++) {
              extraParams[_i - 2] = arguments[_i];
          }
          if (logLevel >= LOG_LEVEL.error && typeof console !== 'undefined') {
              var logMsg = label + message + '\n';
              if (error) {
                  console.error.apply(console, __spreadArray([logMsg + '\n', error], extraParams, false));
              }
              else {
                  console.error.apply(console, __spreadArray([logMsg], extraParams, false));
              }
          }
      }
      /**
       * Log warnings, with or without error object
       */
      function warn(message, error) {
          var extraParams = [];
          for (var _i = 2; _i < arguments.length; _i++) {
              extraParams[_i - 2] = arguments[_i];
          }
          if (logLevel >= LOG_LEVEL.warn && typeof console !== 'undefined') {
              var logMsg = label + message;
              if (error) {
                  console.warn.apply(console, __spreadArray([logMsg + '\n', error], extraParams, false));
              }
              else {
                  console.warn.apply(console, __spreadArray([logMsg], extraParams, false));
              }
          }
      }
      /**
       * Log debug messages
       */
      function debug(message) {
          var extraParams = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              extraParams[_i - 1] = arguments[_i];
          }
          if (logLevel >= LOG_LEVEL.debug && typeof console !== 'undefined') {
              console.debug.apply(console, __spreadArray([label + message], extraParams, false));
          }
      }
      /**
       * Log info messages
       */
      function info(message) {
          var extraParams = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              extraParams[_i - 1] = arguments[_i];
          }
          if (logLevel >= LOG_LEVEL.info && typeof console !== 'undefined') {
              console.info.apply(console, __spreadArray([label + message], extraParams, false));
          }
      }
      return { setLogLevel: setLogLevel, warn: warn, error: error, debug: debug, info: info };
  }
  /**
   * Find dynamic context generating functions and return their results to be merged into the static contexts
   * Combine an array of unchanging contexts with the result of a context-creating function
   *
   * @param dynamicOrStaticContexts - Array of custom context Objects or custom context generating functions
   * @param Parameters - to pass to dynamic context callbacks
   * @returns An array of Self Describing JSON context
   */
  function resolveDynamicContext(dynamicOrStaticContexts) {
      var _a;
      var extraParams = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          extraParams[_i - 1] = arguments[_i];
      }
      return ((_a = dynamicOrStaticContexts === null || dynamicOrStaticContexts === void 0 ? void 0 : dynamicOrStaticContexts.map(function (context) {
          if (typeof context === 'function') {
              try {
                  return context.apply(void 0, extraParams);
              }
              catch (e) {
                  //TODO: provide warning
                  return undefined;
              }
          }
          else {
              return context;
          }
      }).filter(Boolean)) !== null && _a !== void 0 ? _a : []);
  }
  /**
   * Build a self-describing event
   * A custom event type, allowing for an event to be tracked using your own custom schema
   * and a data object which conforms to the supplied schema
   *
   * @param event - Contains the properties and schema location for the event
   * @returns PayloadBuilder to be sent to {@link @snowplow/tracker-core#TrackerCore.track}
   */
  function buildSelfDescribingEvent(event) {
      var _a = event.event, schema = _a.schema, data = _a.data, pb = payloadBuilder();
      var ueJson = {
          schema: 'iglu:com.snowplowanalytics.snowplow/unstruct_event/jsonschema/1-0-0',
          data: { schema: schema, data: data }
      };
      pb.add('e', 'ue');
      pb.addJson('ue_px', 'ue_pr', ueJson);
      return pb;
  }
  /**
   * Build a Link Click Event
   * Used when a user clicks on a link on a webpage, typically an anchor tag `<a>`
   *
   * @param event - Contains the properties for the Link Click event
   * @returns PayloadBuilder to be sent to {@link @snowplow/tracker-core#TrackerCore.track}
   */
  function buildLinkClick(event) {
      var targetUrl = event.targetUrl, elementId = event.elementId, elementClasses = event.elementClasses, elementTarget = event.elementTarget, elementContent = event.elementContent;
      var eventJson = {
          schema: 'iglu:com.snowplowanalytics.snowplow/link_click/jsonschema/1-0-1',
          data: removeEmptyProperties({ targetUrl: targetUrl, elementId: elementId, elementClasses: elementClasses, elementTarget: elementTarget, elementContent: elementContent })
      };
      return buildSelfDescribingEvent({ event: eventJson });
  }
  /**
   * Returns a copy of a JSON with undefined and null properties removed
   *
   * @param event - JSON object to clean
   * @param exemptFields - Set of fields which should not be removed even if empty
   * @returns A cleaned copy of eventJson
   */
  function removeEmptyProperties(event, exemptFields) {
      if (exemptFields === void 0) { exemptFields = {}; }
      var ret = {};
      for (var k in event) {
          if (exemptFields[k] || (event[k] !== null && typeof event[k] !== 'undefined')) {
              ret[k] = event[k];
          }
      }
      return ret;
  }

  /*!
   * Core functionality for Snowplow Browser trackers v3.24.6 (http://bit.ly/sp-js)
   * Copyright 2022 Snowplow Analytics Ltd, 2010 Anthon Pang
   * Licensed under BSD-3-Clause
   */
  /**
   * Extract hostname from URL
   */
  function getHostName(url) {
      // scheme : // [username [: password] @] hostname [: port] [/ [path] [? query] [# fragment]]
      var e = new RegExp('^(?:(?:https?|ftp):)/*(?:[^@]+@)?([^:/#]+)'), matches = e.exec(url);
      return matches ? matches[1] : url;
  }
  /**
   * Cross-browser helper function to add event handler
   */
  function addEventListener(element, eventType, eventHandler, options) {
      if (element.addEventListener) {
          element.addEventListener(eventType, eventHandler, options);
          return true;
      }
      // IE Support
      if (element.attachEvent) {
          return element.attachEvent('on' + eventType, eventHandler);
      }
      element['on' + eventType] = eventHandler;
  }
  /**
   * Convert a criterion object to a filter function
   *
   * @param object - criterion Either {allowlist: [array of allowable strings]}
   *                             or {denylist: [array of allowable strings]}
   *                             or {filter: function (elt) {return whether to track the element}
   * @param boolean - byClass Whether to allowlist/denylist based on an element's classes (for forms)
   *                        or name attribute (for fields)
   */
  function getFilterByClass(criterion) {
      // If the criterion argument is not an object, add listeners to all elements
      if (criterion == null || typeof criterion !== 'object' || Array.isArray(criterion)) {
          return function () {
              return true;
          };
      }
      var inclusive = Object.prototype.hasOwnProperty.call(criterion, 'allowlist');
      var specifiedClassesSet = getSpecifiedClassesSet(criterion);
      return getFilter(criterion, function (elt) {
          return checkClass(elt, specifiedClassesSet) === inclusive;
      });
  }
  /**
   * List the classes of a DOM element without using elt.classList (for compatibility with IE 9)
   */
  function getCssClasses(elt) {
      return elt.className.match(/\S+/g) || [];
  }
  /**
   * Check whether an element has at least one class from a given list
   */
  function checkClass(elt, classList) {
      var classes = getCssClasses(elt);
      for (var _i = 0, classes_1 = classes; _i < classes_1.length; _i++) {
          var className = classes_1[_i];
          if (classList[className]) {
              return true;
          }
      }
      return false;
  }
  function getFilter(criterion, fallbackFilter) {
      if (criterion.hasOwnProperty('filter') && criterion.filter) {
          return criterion.filter;
      }
      return fallbackFilter;
  }
  function getSpecifiedClassesSet(criterion) {
      // Convert the array of classes to an object of the form {class1: true, class2: true, ...}
      var specifiedClassesSet = {};
      var specifiedClasses = criterion.allowlist || criterion.denylist;
      if (specifiedClasses) {
          if (!Array.isArray(specifiedClasses)) {
              specifiedClasses = [specifiedClasses];
          }
          for (var i = 0; i < specifiedClasses.length; i++) {
              specifiedClassesSet[specifiedClasses[i]] = true;
          }
      }
      return specifiedClassesSet;
  }
  /**
   * Dispatch function to all specified trackers from the supplied collection
   *
   * @param trackers - An optional list of trackers to send the event to, or will send to all trackers
   * @param trackerCollection - The collection which the trackers will be selected from
   * @param fn - The function which will run against each tracker
   */
  function dispatchToTrackersInCollection(trackers, trackerCollection, fn) {
      try {
          getTrackersFromCollection(trackers !== null && trackers !== void 0 ? trackers : Object.keys(trackerCollection), trackerCollection).forEach(fn);
      }
      catch (ex) {
          LOG.error('Function failed', ex);
      }
  }
  function getTrackersFromCollection(trackerIds, trackerCollection) {
      var trackers = [];
      for (var _i = 0, trackerIds_1 = trackerIds; _i < trackerIds_1.length; _i++) {
          var id = trackerIds_1[_i];
          if (trackerCollection.hasOwnProperty(id)) {
              trackers.push(trackerCollection[id]);
          }
          else {
              LOG.warn(id + ' not configured');
          }
      }
      return trackers;
  }

  /*
   * Copyright (c) 2022 Snowplow Analytics Ltd, 2010 Anthon Pang
   * All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   *
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the documentation
   *    and/or other materials provided with the distribution.
   *
   * 3. Neither the name of the copyright holder nor the names of its
   *    contributors may be used to endorse or promote products derived from
   *    this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  var _trackers = {};
  var _configuration = {};
  /**
   * Link click tracking
   *
   * Will automatically tracking link clicks once enabled with 'enableLinkClickTracking'
   * or you can manually track link clicks with 'trackLinkClick'
   */
  function LinkClickTrackingPlugin() {
      return {
          activateBrowserPlugin: function (tracker) {
              _trackers[tracker.id] = tracker;
          }
      };
  }
  /**
   * Enable link click tracking
   *
   * @remarks
   * The default behaviour is to use actual click events. However, some browsers
   * (e.g., Firefox, Opera, and Konqueror) don't generate click events for the middle mouse button.
   *
   * To capture more "clicks", the pseudo click-handler uses mousedown + mouseup events.
   * This is not industry standard and is vulnerable to false positives (e.g., drag events).
   */
  function enableLinkClickTracking(configuration, trackers) {
      if (configuration === void 0) { configuration = {}; }
      if (trackers === void 0) { trackers = Object.keys(_trackers); }
      trackers.forEach(function (id) {
          if (_trackers[id]) {
              if (_trackers[id].sharedState.hasLoaded) {
                  // the load event has already fired, add the click listeners now
                  configureLinkClickTracking(configuration, id);
                  addClickListeners(id);
              }
              else {
                  // defer until page has loaded
                  _trackers[id].sharedState.registeredOnLoadHandlers.push(function () {
                      configureLinkClickTracking(configuration, id);
                      addClickListeners(id);
                  });
              }
          }
      });
  }
  /**
   * Add click event listeners to links which have been added to the page since the
   * last time enableLinkClickTracking or refreshLinkClickTracking was used
   *
   * @param trackers - The tracker identifiers which the have their link click state refreshed
   */
  function refreshLinkClickTracking(trackers) {
      if (trackers === void 0) { trackers = Object.keys(_trackers); }
      trackers.forEach(function (id) {
          if (_trackers[id]) {
              if (_trackers[id].sharedState.hasLoaded) {
                  addClickListeners(id);
              }
              else {
                  _trackers[id].sharedState.registeredOnLoadHandlers.push(function () {
                      addClickListeners(id);
                  });
              }
          }
      });
  }
  /**
   * Manually log a click
   *
   * @param event - The event information
   * @param trackers - The tracker identifiers which the event will be sent to
   */
  function trackLinkClick(event, trackers) {
      if (trackers === void 0) { trackers = Object.keys(_trackers); }
      dispatchToTrackersInCollection(trackers, _trackers, function (t) {
          t.core.track(buildLinkClick(event), event.context, event.timestamp);
      });
  }
  /*
   * Process clicks
   */
  function processClick(tracker, sourceElement, context) {
      var parentElement, tag, elementId, elementClasses, elementTarget, elementContent;
      while ((parentElement = sourceElement.parentElement) !== null &&
          parentElement != null &&
          (tag = sourceElement.tagName.toUpperCase()) !== 'A' &&
          tag !== 'AREA') {
          sourceElement = parentElement;
      }
      var anchorElement = sourceElement;
      if (anchorElement.href != null) {
          // browsers, such as Safari, don't downcase hostname and href
          var originalSourceHostName = anchorElement.hostname || getHostName(anchorElement.href), sourceHostName = originalSourceHostName.toLowerCase(), sourceHref = anchorElement.href.replace(originalSourceHostName, sourceHostName), scriptProtocol = new RegExp('^(javascript|vbscript|jscript|mocha|livescript|ecmascript):', 'i');
          // Ignore script pseudo-protocol links
          if (!scriptProtocol.test(sourceHref)) {
              elementId = anchorElement.id;
              elementClasses = getCssClasses(anchorElement);
              elementTarget = anchorElement.target;
              elementContent = _configuration[tracker.id].linkTrackingContent ? anchorElement.innerHTML : undefined;
              // decodeUrl %xx
              sourceHref = unescape(sourceHref);
              tracker.core.track(buildLinkClick({
                  targetUrl: sourceHref,
                  elementId: elementId,
                  elementClasses: elementClasses,
                  elementTarget: elementTarget,
                  elementContent: elementContent
              }), resolveDynamicContext(context, sourceElement));
          }
      }
  }
  /*
   * Return function to handle click event
   */
  function getClickHandler(tracker, context) {
      return function (evt) {
          var button, target;
          evt = evt || window.event;
          button = evt.which || evt.button;
          target = evt.target || evt.srcElement;
          // Using evt.type (added in IE4), we avoid defining separate handlers for mouseup and mousedown.
          if (evt.type === 'click') {
              if (target) {
                  processClick(_trackers[tracker], target, context);
              }
          }
          else if (evt.type === 'mousedown') {
              if ((button === 1 || button === 2) && target) {
                  _configuration[tracker].lastButton = button;
                  _configuration[tracker].lastTarget = target;
              }
              else {
                  _configuration[tracker].lastButton = _configuration[tracker].lastTarget = null;
              }
          }
          else if (evt.type === 'mouseup') {
              if (button === _configuration[tracker].lastButton && target === _configuration[tracker].lastTarget) {
                  processClick(_trackers[tracker], target, context);
              }
              _configuration[tracker].lastButton = _configuration[tracker].lastTarget = null;
          }
      };
  }
  /*
   * Add click listener to a DOM element
   */
  function addClickListener(tracker, element) {
      if (_configuration[tracker].linkTrackingPseudoClicks) {
          // for simplicity and performance, we ignore drag events
          addEventListener(element, 'mouseup', getClickHandler(tracker, _configuration[tracker].linkTrackingContext), false);
          addEventListener(element, 'mousedown', getClickHandler(tracker, _configuration[tracker].linkTrackingContext), false);
      }
      else {
          addEventListener(element, 'click', getClickHandler(tracker, _configuration[tracker].linkTrackingContext), false);
      }
  }
  /*
   * Configures link click tracking: how to filter which links will be tracked,
   * whether to use pseudo click tracking, and what context to attach to link_click events
   */
  function configureLinkClickTracking(_a, tracker) {
      var _b = _a === void 0 ? {} : _a, options = _b.options, pseudoClicks = _b.pseudoClicks, trackContent = _b.trackContent, context = _b.context;
      _configuration[tracker] = {
          linkTrackingContent: trackContent,
          linkTrackingContext: context,
          linkTrackingPseudoClicks: pseudoClicks,
          linkTrackingFilter: getFilterByClass(options)
      };
  }
  /*
   * Add click handlers to anchor and AREA elements, except those to be ignored
   */
  function addClickListeners(trackerId) {
      var _a, _b;
      var linkElements = document.links, i;
      for (i = 0; i < linkElements.length; i++) {
          // Add a listener to link elements which pass the filter and aren't already tracked
          if (((_b = (_a = _configuration[trackerId]).linkTrackingFilter) === null || _b === void 0 ? void 0 : _b.call(_a, linkElements[i])) && !linkElements[i][trackerId]) {
              addClickListener(trackerId, linkElements[i]);
              linkElements[i][trackerId] = true;
          }
      }
  }

  exports.LinkClickTrackingPlugin = LinkClickTrackingPlugin;
  exports.enableLinkClickTracking = enableLinkClickTracking;
  exports.refreshLinkClickTracking = refreshLinkClickTracking;
  exports.trackLinkClick = trackLinkClick;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.umd.js.map
