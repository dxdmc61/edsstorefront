const ConditionType = {
  MATCHER: "matcher",
  GROUP: "group",
  HISTORICAL: "historical"
};
const MatcherType = {
  EQUALS: "eq",
  NOT_EQUALS: "ne",
  EXISTS: "ex",
  NOT_EXISTS: "nx",
  GREATER_THAN: "gt",
  GREATER_THAN_OR_EQUAL_TO: "ge",
  LESS_THAN: "lt",
  LESS_THAN_OR_EQUAL_TO: "le",
  CONTAINS: "co",
  NOT_CONTAINS: "nc",
  STARTS_WITH: "sw",
  ENDS_WITH: "ew"
};
const LogicType = {
  AND: "and",
  OR: "or"
};
const SearchType = {
  ANY: "any",
  ORDERED: "ordered"
};

function isObjectOrUndefined(value) {
  return typeof value === "object" || typeof value === "undefined";
}

function createEquals() {
  return {
    matches: (context, key, values = []) => {
      if (isObjectOrUndefined(context[key])) {
        return false;
      }
      const contextValue = String(context[key]).toLowerCase();
      for (let i = 0; i < values.length; i += 1) {
        if (!isObjectOrUndefined(values[i]) && contextValue === String(values[i]).toLowerCase()) {
          return true;
        }
      }
      return false;
    }
  };
}

function createNotEquals() {
  return {
    matches: (context, key, values = []) => {
      if (isObjectOrUndefined(context[key])) {
        return false;
      }
      const contextValue = String(context[key]).toLowerCase();
      for (let i = 0; i < values.length; i += 1) {
        if (!isObjectOrUndefined(values[i]) && contextValue === String(values[i]).toLowerCase()) {
          return false;
        }
      }
      return true;
    }
  };
}

function createExists() {
  return {
    matches: (context, key) => {
      return typeof context[key] !== "undefined" && context[key] !== null;
    }
  };
}

function createNotExists() {
  return {
    matches: (context, key) => {
      return typeof context[key] === "undefined" || context[key] === null;
    }
  };
}

function isNumber(value) {
  return typeof value === "number";
}

function createGreaterThan() {
  return {
    matches: (context, key, values = []) => {
      const needle = context[key];
      if (!isNumber(needle)) {
        return false;
      }
      for (let i = 0; i < values.length; i += 1) {
        if (isNumber(values[i]) && needle > values[i]) {
          return true;
        }
      }
      return false;
    }
  };
}

function createGreaterThanEquals() {
  return {
    matches: (context, key, values = []) => {
      const needle = context[key];
      if (!isNumber(needle)) {
        return false;
      }
      for (let i = 0; i < values.length; i += 1) {
        if (isNumber(values[i]) && needle >= values[i]) {
          return true;
        }
      }
      return false;
    }
  };
}

function createLessThan() {
  return {
    matches: (context, key, values = []) => {
      const needle = context[key];
      if (!isNumber(needle)) {
        return false;
      }
      for (let i = 0; i < values.length; i += 1) {
        if (isNumber(values[i]) && needle < values[i]) {
          return true;
        }
      }
      return false;
    }
  };
}

function createLessThanEquals() {
  return {
    matches: (context, key, values = []) => {
      const needle = context[key];
      if (!isNumber(needle)) {
        return false;
      }
      for (let i = 0; i < values.length; i += 1) {
        if (isNumber(values[i]) && needle <= values[i]) {
          return true;
        }
      }
      return false;
    }
  };
}

function createContains() {
  return {
    matches: (context, key, values = []) => {
      if (isObjectOrUndefined(context[key])) {
        return false;
      }
      const contextValue = String(context[key]).toLowerCase();
      for (let i = 0; i < values.length; i += 1) {
        if (!isObjectOrUndefined(values[i]) && contextValue.indexOf(String(values[i]).toLowerCase()) !== -1) {
          return true;
        }
      }
      return false;
    }
  };
}

function createNotContains() {
  return {
    matches: (context, key, values = []) => {
      if (isObjectOrUndefined(context[key])) {
        return false;
      }
      const contextValue = String(context[key]).toLowerCase();
      for (let i = 0; i < values.length; i += 1) {
        if (!isObjectOrUndefined(values[i]) && contextValue.indexOf(String(values[i]).toLowerCase()) !== -1) {
          return false;
        }
      }
      return true;
    }
  };
}

function createStartsWith() {
  return {
    matches: (context, key, values = []) => {
      if (isObjectOrUndefined(context[key])) {
        return false;
      }
      const contextValue = String(context[key]).toLowerCase();
      for (let i = 0; i < values.length; i += 1) {
        if (!isObjectOrUndefined(values[i]) && contextValue.startsWith(String(values[i]).toLowerCase())) {
          return true;
        }
      }
      return false;
    }
  };
}

function createEndsWith() {
  return {
    matches: (context, key, values = []) => {
      if (isObjectOrUndefined(context[key])) {
        return false;
      }
      const contextValue = String(context[key]).toLowerCase();
      for (let i = 0; i < values.length; i += 1) {
        if (!isObjectOrUndefined(values[i]) && contextValue.endsWith(values[i].toLowerCase())) {
          return true;
        }
      }
      return false;
    }
  };
}

const MATCHERS = {
  [MatcherType.EQUALS]: createEquals(),
  [MatcherType.NOT_EQUALS]: createNotEquals(),
  [MatcherType.EXISTS]: createExists(),
  [MatcherType.NOT_EXISTS]: createNotExists(),
  [MatcherType.GREATER_THAN]: createGreaterThan(),
  [MatcherType.GREATER_THAN_OR_EQUAL_TO]: createGreaterThanEquals(),
  [MatcherType.LESS_THAN]: createLessThan(),
  [MatcherType.LESS_THAN_OR_EQUAL_TO]: createLessThanEquals(),
  [MatcherType.CONTAINS]: createContains(),
  [MatcherType.NOT_CONTAINS]: createNotContains(),
  [MatcherType.STARTS_WITH]: createStartsWith(),
  [MatcherType.ENDS_WITH]: createEndsWith()
};
function getMatcher(key) {
  return MATCHERS[key];
}

function isUndefined(value) {
  return typeof value === "undefined";
}

const IAM_ID = "iam.id";
const ID = "id";
const IAM_EVENT_TYPE = "iam.eventType";
const EVENT_TYPE = "eventType";
const TYPE = "type";
const VALID_EVENT_TYPES = [IAM_EVENT_TYPE, EVENT_TYPE, TYPE];
const VALID_EVENT_IDS = [IAM_ID, ID];
function checkForHistoricalMatcher(eventCount, matcherKey, value) {
  switch (matcherKey) {
    case MatcherType.GREATER_THAN:
      return eventCount > value;
    case MatcherType.GREATER_THAN_OR_EQUAL_TO:
      return eventCount >= value;
    case MatcherType.LESS_THAN:
      return eventCount < value;
    case MatcherType.LESS_THAN_OR_EQUAL_TO:
      return eventCount <= value;
    case MatcherType.EQUALS:
      return eventCount === value;
    case MatcherType.NOT_EQUALS:
      return eventCount !== value;
    default:
      return false;
  }
}
function oneOf(context, properties) {
  for (let i = 0; i < properties.length; i += 1) {
    if (!isUndefined(context[properties[i]])) {
      return context[properties[i]];
    }
  }
  return undefined;
}
function eventSatisfiesCondition(historicalEventCondition, eventContext) {
  const eventKeys = Object.keys(historicalEventCondition);
  for (let i = 0; i < eventKeys.length; i += 1) {
    const key = eventKeys[i];
    const {
      event = {}
    } = eventContext;
    if (event[eventKeys[i]] !== historicalEventCondition[key]) {
      return false;
    }
  }
  return true;
}
function queryAndCountAnyEvent(events, context, from, to) {
  return events.reduce((countTotal, event) => {
    const eventType = oneOf(event, VALID_EVENT_TYPES);
    if (!eventType) {
      return countTotal;
    }
    const eventsOfType = context.events[eventType];
    if (!eventsOfType) {
      return countTotal;
    }
    const eventId = oneOf(event, VALID_EVENT_IDS);
    if (!eventId) {
      return countTotal;
    }
    const contextEvent = eventsOfType[eventId];
    if (!contextEvent) {
      return countTotal;
    }
    if (!eventSatisfiesCondition(event, contextEvent)) {
      return countTotal;
    }
    const {
      count: eventCount = 1
    } = contextEvent;
    if (isUndefined(from) || isUndefined(to) || contextEvent.timestamp >= from && contextEvent.timestamp <= to) {
      return countTotal + eventCount;
    }
    return countTotal;
  }, 0);
}
function queryAndCountOrderedEvent(events, context, from, to) {
  let previousEventTimestamp = from;
  const sameSequence = events.every(event => {
    const eventType = oneOf(event, VALID_EVENT_TYPES);
    if (!eventType) {
      return false;
    }
    const eventsOfType = context.events[eventType];
    if (!eventsOfType) {
      return false;
    }
    const eventId = oneOf(event, VALID_EVENT_IDS);
    if (!eventId) {
      return false;
    }
    const contextEvent = eventsOfType[eventId];
    if (!eventSatisfiesCondition(event, contextEvent)) {
      return false;
    }
    if (contextEvent === null || isUndefined(contextEvent) || contextEvent.count === 0) {
      return false;
    }
    const ordered = (isUndefined(previousEventTimestamp) || contextEvent.timestamp >= previousEventTimestamp) && (isUndefined(to) || contextEvent.timestamp <= to);
    previousEventTimestamp = contextEvent.timestamp;
    return ordered;
  });
  return sameSequence ? 1 : 0;
}

function evaluateAnd(context, conditions) {
  let result = true;
  for (let i = 0; i < conditions.length; i += 1) {
    result = result && conditions[i].evaluate(context);
  }
  return result;
}
function evaluateOr(context, conditions) {
  let result = false;
  for (let i = 0; i < conditions.length; i += 1) {
    result = result || conditions[i].evaluate(context);
    if (result) {
      return true;
    }
  }
  return false;
}
function createRules(version, rules) {
  return {
    version,
    rules
  };
}
function createRule(condition, consequences) {
  return {
    execute: context => {
      if (condition.evaluate(context)) {
        return consequences;
      }
      return [];
    },
    toString: () => {
      return `Rule{condition=${condition}, consequences=${consequences}}`;
    }
  };
}
function createCondition(type, definition) {
  return {
    evaluate: context => {
      return definition.evaluate(context);
    },
    toString() {
      return `Condition{type=${type}, definition=${definition}}`;
    }
  };
}
function createConsequence(id, type, detail) {
  return {
    id,
    type,
    detail
  };
}
function createGroupDefinition(logic, conditions) {
  return {
    evaluate: context => {
      if (LogicType.AND === logic) {
        return evaluateAnd(context, conditions);
      }
      if (LogicType.OR === logic) {
        return evaluateOr(context, conditions);
      }
      return false;
    }
  };
}
function createMatcherDefinition(key, matcherKey, values) {
  return {
    evaluate: context => {
      const matcher = getMatcher(matcherKey);
      if (!matcher) {
        return false;
      }
      return matcher.matches(context, key, values);
    }
  };
}
function createHistoricalDefinition(events, matcherKey, value, from, to, searchType) {
  return {
    evaluate: context => {
      let eventCount;
      if (SearchType.ORDERED === searchType) {
        eventCount = queryAndCountOrderedEvent(events, context, from, to);
      } else {
        eventCount = queryAndCountAnyEvent(events, context, from, to);
      }
      return checkForHistoricalMatcher(eventCount, matcherKey, value);
    }
  };
}

function parseMatcherDefinition(definition) {
  const {
    key,
    matcher,
    values
  } = definition;
  return createMatcherDefinition(key, matcher, values);
}
function parseGroupDefinition(definition) {
  const {
    logic,
    conditions
  } = definition;
  return createGroupDefinition(logic, conditions.map(parseCondition));
}
function parseHistoricalDefinition(definition) {
  const {
    events,
    from,
    to,
    matcher,
    value,
    searchType
  } = definition;
  return createHistoricalDefinition(events, matcher, value, from, to, searchType);
}
function parseCondition(condition) {
  const {
    type,
    definition
  } = condition;
  if (ConditionType.MATCHER === type) {
    return createCondition(type, parseMatcherDefinition(definition));
  }
  if (ConditionType.GROUP === type) {
    return createCondition(type, parseGroupDefinition(definition));
  }
  if (ConditionType.HISTORICAL === type) {
    return createCondition(type, parseHistoricalDefinition(definition));
  }
  throw new Error("Can not parse condition");
}
function parseConsequence(consequence) {
  const {
    id,
    type,
    detail
  } = consequence;
  return createConsequence(id, type, detail);
}
function parseRule(rule) {
  const {
    condition,
    consequences
  } = rule;
  return createRule(parseCondition(condition), consequences.map(parseConsequence));
}
function parseRules(ruleset) {
  const {
    version,
    rules
  } = ruleset;
  return createRules(version, rules.map(parseRule));
}

function RulesEngine(ruleset) {
  const {
    version,
    rules
  } = parseRules(ruleset);
  return {
    execute: context => rules.map(rule => rule.execute(context)).filter(arr => arr.length > 0),
    getVersion: () => version,
    numRules: () => rules.length
  };
}

export { RulesEngine as default };
